#!/bin/bash
# VM Manager Script for NixOS 25.05 UEFI/Secure Boot VM

# --- Configuration Variables ---

# Paths (Ensure these directories/files exist!)
VM_NAME="NixOS_25.11_VM"
VDI_PATH="/home/rhys/Documents/VM/VDI/nixos.qcow2"
VDI_SIZE="64G" # New: Size for the VDI if it needs to be created
ISO_PATH="/home/rhys/Downloads/ISO/nixos-minimal-25.05.810995.5da4a26309e7-x86_64-linux.iso"

# UEFI/Secure Boot Paths (Active for 'start' command)
BIOS_CODE_PATH="/home/rhys/Documents/VM/bios/OVMF_CODE_4M.secboot.fd"
BIOS_VARS_PATH="/home/rhys/Documents/VM/bios/OVMF_VARS_4M.secboot.fd"

# Hardware Configuration
VM_MEMORY="8G" # Default VM Memory (e.g., 4G, 8G, 16G)

# TPM Paths (Configuration for swtpm)
TPM_STATE_DIR="/home/rhys/Documents/VM/nixos/tpm"              # Directory for TPM state files
TPM_SOCKET_PATH="/home/rhys/Documents/VM/nixos/tpm/swtpm-sock" # Socket QEMU connects to
SWTPM_PID_FILE="/tmp/swtpm-nixos-$USER.pid"
SWTPM_BIN="swtpm"
QEMU_BIN="qemu-system-x86_64"
QEMU_IMG_BIN="qemu-img"

# Runtime/Control Variables
MONITOR_SOCKET="/tmp/qemu-$USER-nixos-monitor.sock"
PID_FILE="/tmp/qemu-$USER-nixos.pid"

# --- Functions ---

# Function to set up environment variables based on GPU vendor preference
setup_gpu_environment() {
  local gpu_preference="$1"

  echo "--- Setting up GPU environment ---"

  # Unset variables to ensure a clean slate
  unset DRI_PRIME
  unset __GLX_VENDOR_LIBRARY_NAME
  unset __EGL_VENDOR_LIBRARY_FILENAMES

  if [[ "$gpu_preference" == "amd" || "$gpu_preference" == "radeon" ]]; then
    echo "Preference: AMD/Radeon GPU. Using integrated graphics (DRI_PRIME=0)."
    export DRI_PRIME=0
  elif [[ "$gpu_preference" == "nvidia" ]]; then
    echo "Preference: NVIDIA GPU. Using discrete graphics (DRI_PRIME=1) and NVIDIA variables."
    export DRI_PRIME=1
    export __GLX_VENDOR_LIBRARY_NAME=nvidia
    export __EGL_VENDOR_LIBRARY_FILENAMES="/usr/share/glvnd/egl_vendor.d/10_nvidia.json"
  else
    echo "No GPU preference specified or invalid option. Using system default."
    # Let the system decide which GPU to use by default
  fi

  # Generic backend setting
  export GDK_BACKEND=x11
}


# Function to clean up temporary files (PID and monitor socket)
cleanup() {
  echo ""
  echo "--- Cleaning up temporary files ---"

  # 1. Clean up QEMU files
  [ -f "$MONITOR_SOCKET" ] && rm -f "$MONITOR_SOCKET"
  [ -f "$PID_FILE" ] && rm -f "$PID_FILE"
  [ -S "/tmp/nixos-vm.sock" ] && rm -f "/tmp/nixos-vm.sock"

  # 2. Clean up swtpm if we started it
  if [ -f "$SWTPM_PID_FILE" ]; then
    SWTPM_PID=$(cat "$SWTPM_PID_FILE")
    if kill -0 "$SWTPM_PID" 2>/dev/null; then
      echo "Stopping swtpm process (PID: $SWTPM_PID)..."
      # Send TERM signal to swtpm
      kill "$SWTPM_PID" 2>/dev/null
    fi
    rm -f "$SWTPM_PID_FILE"
  fi
}

# Function to start the swtpm process
start_swtpm() {
  # Ensure the TPM state directory exists
  mkdir -p "$TPM_STATE_DIR" 2>/dev/null

  # Check if the socket exists. If not, start the software TPM.
  if [ ! -S "$TPM_SOCKET_PATH" ]; then
    echo "TPM socket not found at $TPM_SOCKET_PATH. Starting swtpm in background..."

    # Start swtpm with the corrected configuration and a PID file for cleanup
    "$SWTPM_BIN" socket -d --tpm2 \
      --tpmstate dir="$TPM_STATE_DIR" \
      --ctrl type=unixio,path="$TPM_SOCKET_PATH" \
      --pid file="$SWTPM_PID_FILE" \
      --log file="/tmp/swtpm-nixos-$USER.log",level=2

    # Give swtpm a moment to start and create the socket
    sleep 1
    if [ ! -S "$TPM_SOCKET_PATH" ]; then
      echo "Error: swtpm failed to start or create socket. Check /tmp/swtpm-nixos-$USER.log for details."
      return 1 # Fail if swtpm doesn't start
    else
      echo "swtpm started successfully."
    fi
  fi
  return 0
}

# New Function: Check and create VDI if it doesn't exist
check_and_create_vdi() {
  if [ ! -f "$VDI_PATH" ]; then
    echo "VDI file not found at $VDI_PATH."
    VDI_DIR=$(dirname "$VDI_PATH")

    # Ensure the VDI directory exists
    mkdir -p "$VDI_DIR" || {
      echo "Error: Failed to create directory $VDI_DIR"
      return 1
    }

    echo "Creating new VDI: $VDI_PATH (${VDI_SIZE})..."
    # Create a new qcow2 image with specified size
    if "$QEMU_IMG_BIN" create -f qcow2 "$VDI_PATH" "$VDI_SIZE"; then
      echo "VDI created successfully."
      return 0
    else
      echo "Error: Failed to create VDI using $QEMU_IMG_BIN. Check if qemu-img is installed and available."
      return 1
    fi
  else
    echo "VDI file found: $VDI_PATH."
    return 0
  fi
}

# New Function: Remove the VDI and associated TPM state files
remove_vdi() {
  echo "--- Removing VDI and associated files ---"

  # 1. Remove VDI
  if [ -f "$VDI_PATH" ]; then
    read -r -p "Are you sure you want to remove the VDI at '$VDI_PATH'? (y/N): " confirmation
    if [[ "$confirmation" =~ ^[Yy]$ ]]; then
      rm -v "$VDI_PATH"
      echo "VDI removed."
    else
      echo "VDI removal cancelled."
      return 0
    fi
  else
    echo "VDI not found at '$VDI_PATH'. Nothing to remove."
  fi

  # 2. Remove TPM state directory
  if [ -d "$TPM_STATE_DIR" ]; then
    echo "Removing TPM state directory: $TPM_STATE_DIR"
    # Add confirmation for TPM removal, as it stores security-sensitive state
    read -r -p "Also remove the TPM state directory '$TPM_STATE_DIR'? This is usually safe after VDI removal. (y/N): " tpm_confirmation
    if [[ "$tpm_confirmation" =~ ^[Yy]$ ]]; then
      rm -rfv "$TPM_STATE_DIR"
      echo "TPM state directory removed."
    else
      echo "TPM state directory removal cancelled."
    fi
  fi
  return 0
}

# Function for Post-Install/Run Mode (UEFI/Secure Boot)
start_vm() {
  local gpu_pref="$1"
  check_and_create_vdi || return 1 # Check and create VDI before starting
  start_swtpm || return 1
  setup_gpu_environment "$gpu_pref" # Set up GPU environment variables

  # VM is run in the foreground to display the window.
  echo "--- Starting $VM_NAME in FOREGROUND ---"
  echo "Monitor Socket: $MONITOR_SOCKET"
  echo "USE CTRL+C IN THIS TERMINAL TO STOP THE VM."

  # The QEMU command for UEFI/Secure Boot with TPM
  "$QEMU_BIN" \
    -enable-kvm \
    -cpu host,topoext=on \
    -smp cores=4,threads=2 \
    -m "$VM_MEMORY" \
    -object memory-backend-memfd,id=mem1,size="$VM_MEMORY",share=on \
    -machine q35,smm=on,memory-backend=mem1 \
    -boot menu=on,splash-time=5000 \
    \
    -drive if=pflash,format=raw,readonly=on,file="$BIOS_CODE_PATH" \
    -drive if=pflash,format=raw,file="$BIOS_VARS_PATH" \
    \
    -drive file="$VDI_PATH",if=none,id=disk0,format=qcow2 \
    -device virtio-blk-pci,drive=disk0 \
    \
    -chardev socket,id=chrtpm,path="$TPM_SOCKET_PATH" \
    -tpmdev emulator,id=tpm0,chardev=chrtpm \
    -device tpm-tis,tpmdev=tpm0 \
    \
    -object rng-random,filename=/dev/urandom,id=rng0 \
    -device virtio-rng-pci,rng=rng0 \
    -nic user,model=virtio \
    -usb \
    -device virtio-keyboard-pci \
    -device virtio-tablet-pci \
    \
    -vga none \
    -device virtio-vga-gl,hostmem=8G,blob=true,venus=true \
    -display egl-headless,rendernode=/dev/dri/renderD129 \
    -spice unix=on,addr=/tmp/nixos-vm.sock,gl=off,disable-ticketing=on \
    -name "$VM_NAME" \
    -monitor unix:"$MONITOR_SOCKET",server=on,nowait \
    -pidfile "$PID_FILE" &

  echo "Waiting for Spice socket..."
  MAX_RETRIES=10
  COUNT=0
  while [ ! -S /tmp/nixos-vm.sock ] && [ $COUNT -lt $MAX_RETRIES ]; do
    sleep 0.5
    ((COUNT++))
  done

  if [ ! -S /tmp/nixos-vm.sock ]; then
    echo "Error: Spice socket was not created. Check QEMU logs."
    return 1
  fi

  echo "Launching Remote Viewer... "
  remote-viewer --spice-controller spice+unix:///tmp/nixos-vm.sock --hotkeys=release-cursor=ctrl+alt >/dev/null 2>&1 &

  echo "VM and Viewer are running. Use Ctrl+C in this terminal to stop everything."
  wait $(cat "$PID_FILE")

  echo "VM process exited."
}

# Function for Pre-Install Mode (Legacy Boot)
install_vm() {
  local gpu_pref="$1"
  check_and_create_vdi || return 1 # Check and create VDI before starting
  start_swtpm || return 1
  setup_gpu_environment "$gpu_pref"

  # VM is run in the foreground to display the window.
  echo "--- Starting $VM_NAME in FOREGROUND ---"
  echo "Monitor Socket: $MONITOR_SOCKET"
  echo "USE CTRL+C IN THIS TERMINAL TO STOP THE VM."

  # The QEMU command for Legacy Boot (Install Mode) with TPM
  "$QEMU_BIN" \
    -enable-kvm \
    -machine q35,smm=on \
    -m "$VM_MEMORY" \
    -cpu host,topoext=on \
    -smp cores=4,threads=2 \
    -boot menu=on \
    \
    -drive if=pflash,format=raw,readonly=on,file="$BIOS_CODE_PATH" \
    -drive if=pflash,format=raw,file="$BIOS_VARS_PATH" \
    \
    -drive file="$VDI_PATH",if=none,id=disk0,format=qcow2 \
    -device virtio-blk-pci,drive=disk0 \
    -cdrom "$ISO_PATH" \
    \
    -chardev socket,id=chrtpm,path="$TPM_SOCKET_PATH" \
    -tpmdev emulator,id=tpm0,chardev=chrtpm \
    -device tpm-tis,tpmdev=tpm0 \
    \
    -object rng-random,filename=/dev/urandom,id=rng0 \
    -device virtio-rng-pci,rng=rng0 \
    -nic user,model=virtio \
    -usb \
    -device usb-tablet \
    \
    -vga std \
    -display gtk,gl=on \
    -name "$VM_NAME" \
    -monitor unix:"$MONITOR_SOCKET",server=on,nowait

  echo "VM process exited."
}

# Function to stop the QEMU VM gracefully
stop_vm() {
  # NOTE: This function is primarily designed to stop a VM running in background mode.
  # If the VM was started with 'start' or 'install', use Ctrl+C instead.
  if [ ! -f "$PID_FILE" ]; then
    echo "VM is not running in background (PID file not found). Use Ctrl+C if it's running in the foreground."
    exit 1
  fi

  if [ -S "$MONITOR_SOCKET" ]; then
    echo "Attempting graceful shutdown via monitor socket..."
    # Send the 'quit' command to the monitor socket
    echo "quit" | socat - "$MONITOR_SOCKET"
    sleep 2
  else
    echo "Monitor socket not found. Sending SIGTERM..."
    kill -TERM "$(cat "$PID_FILE")"
    sleep 2
  fi

  # Check if the process is still running
  if kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
    echo "VM did not shut down gracefully. Forcing kill..."
    kill -KILL "$(cat "$PID_FILE")"
  fi

  cleanup
  echo "VM shut down and cleaned up."
}

# --- Main Logic ---

# Trap function to ensure cleanup runs on script exit or interrupt (Ctrl+C)
trap cleanup EXIT

COMMAND="$1"
GPU_PREF="$2"

case "$COMMAND" in
start)
  start_vm "$GPU_PREF"
  ;;
install)
  install_vm "$GPU_PREF"
  ;;
stop)
  stop_vm
  ;;
restart)
  echo "Restarting a foreground process is not reliable. Running 'start' now."
  start_vm "$GPU_PREF"
  ;;
remove-vdi) # New Case Option
  remove_vdi
  ;;
*)
  echo "Usage: $0 {start|install|stop|restart|remove-vdi} [amd|nvidia]"
  echo "  start:      Starts the VM in UEFI/Secure Boot mode (Post-Install)."
  echo "  install:    Starts the VM in Legacy Boot mode (Pre-Install)."
  echo "  stop:       Attempts to gracefully shut down a background VM process."
  echo "  restart:    Restarts the VM (runs 'start')."
  echo "  remove-vdi: Permanently removes the VDI file and asks to remove the TPM state."
  echo "  [amd|nvidia]: Optionally specify which GPU to use (amd for Radeon, nvidia for NVIDIA)."
  exit 1
  ;;
esac

exit 0
